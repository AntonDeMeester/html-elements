{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HTML Elements","text":"<p>HTML Elements allows you to write HTML website while staying completely in Python. This will allow you to create SPA-like components, but keep your presentation layer in Python.</p> <p>Because it is in pure Python, it allows to use all the Python goodies such as functions, linting, type checking.</p> <p>Check out the reasoning behind the package in the Background</p>"},{"location":"#example","title":"Example","text":"<p>To create this form (made with Bulma)</p> <pre><code>&lt;form&gt;\n  &lt;div class=\"field\"&gt;\n    &lt;label class=\"label\"&gt;\n      Name\n    &lt;/label&gt;\n    &lt;div class=\"control\"&gt;\n      &lt;input class=\"input\" name=\"name\" placeholder=\"Name\" type=\"text\" /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;div class=\"field\"&gt;\n    &lt;label class=\"label\"&gt;\n      Email\n    &lt;/label&gt;\n    &lt;div class=\"control\"&gt;\n      &lt;input class=\"input\" name=\"email\" placeholder=\"Email\" type=\"email\" /&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;button class=\"button\" type=\"submit\"&gt;\n    Submit\n  &lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <p>You write</p> <pre><code>from html_elements import elements as e\n\n\ndef Input(type: str, label: str) -&gt; e.BaseHtmlElement:\n    display = label.title()\n    return e.Div(\n        [\n            e.Label([display], classes=[\"label\"]),\n            e.Div(\n                [e.Input(classes=[\"input\"], type=type, placeholder=display, name=label)],\n                classes=[\"control\"]\n            )\n        ],\n        classes=[\"field\"]\n    )\n\nhtml = e.Form([\n    Input(\"text\", \"name\"),\n    Input(\"email\", \"email\"),\n    e.Button([\"Submit\"], classes=[\"button\"], type=\"submit\")\n])\n\nraw = html.to_html(indent_step=2)\n</code></pre>"},{"location":"background/","title":"Background","text":""},{"location":"background/#the-current-way","title":"The current way","text":"<p>Building web apps these days is difficult.  Either you go for the full Single Page App (SPA) way and then you need 2 apps, multiple languages and difficult synchronisation problems. Or you can use one of the other really cool Python apps and templating languages such as Jinja or Django.</p> <p>However, even in Jinja and Django, you write pure HTML.  This is fine as long as you are creating HTML. However, once you need to interpolate Python object, you lose all your Python goodies.  You don't have editor autocomplete, type checking, standard python functions etc. </p> <p>Additionally, modern web apps have learned us that reusable components are a good idea.  Write something once, use it multiple times.  Change it once and your whole app is updated! While SPA's have this, in Jinja and Django this is more difficult.  And this is used again in HTML with more difficult access to autocomplete and readability.</p>"},{"location":"background/#html-elements","title":"HTML Elements","text":"<p>Enter HTML Elements. </p> <p>Why create HTML and interpolate Python object in it if we can create Python and format the HTML afterwards.  Because we stay in Python, we have access to all Python goodies. </p>"},{"location":"background/#components","title":"Components","text":"<p>Using components we can reuse our code. Because every web page is or wants to be unique, the library does not provide a components itself. It is up to you to create them.  Or alternatively you can just remake them from an existing component library by looking into their HTML (don't tell the I sent you.)</p> <p>For example, making an Input element with label, using the excellent Bulma framework.</p> <pre><code>--8&lt;-- \"docs_code/background/input.py\":1:14\n</code></pre> <p>It creates multiple HTML elements, but we only need to provide 2 input values.  This means we can simplify our code quite a bit.</p> <p>Even if we make this a lot more complex, with the right defaults, we can still make it easy to implement with smart defaults. This way we can make the default easy, while making the complex possible.</p> <pre><code>--8&lt;-- \"docs_code/background/input.py\":16:38\n</code></pre>"},{"location":"background/#editor-support-and-linting","title":"Editor support and linting","text":"<p>When we create functions, we can type them and set the arguments, keyword arguments  which our editors understand. Our editor will then show us what is there.</p> <p>VS code shows the following</p> <p></p> <p>We can even use Python objects for inputs of our components, which can smartly take the information from it.</p> <pre><code>--8&lt;-- \"docs_code/background/table.py\":1:23\n</code></pre> <p>If we would provide not a list or a sequence, it would provide an error.</p> <pre><code># Continued from last one\n\n--8&lt;-- \"docs_code/background/table.py\":25:25\n</code></pre> <p>It provides the following error in VS code</p> <p></p> <p>And running a type checker like mypy provides the following error.</p> <pre><code>docs/examples.py:31: error: Argument 1 to \"SimpleTable\" has incompatible type \"object\"; expected \"Sequence[Any]\"  [arg-type]\n</code></pre> <p>This is an improvement over Jinja and Django, which do not understand input values or python typing.  It makes our lives easier by helping us out while developing.  And it prevents us from making errors by catching input and typing errors when linting.</p>"},{"location":"basic_reference/","title":"Basic Reference","text":""},{"location":"basic_reference/#class-basehtmlelement","title":"Class <code>BaseHtmlElement</code>","text":"<p>The basic class with methods which all HTML Elements will use. It does not have any attributes. The <code>__init__</code> parameters will be defined by the subclasses and its defined <code>HtmlAttribute</code>s.</p>"},{"location":"basic_reference/#method-to_html","title":"Method <code>to_html</code>","text":"<pre><code>def to_html(self, indent: int = 0, indent_step: int = 2, format: bool = True) -&gt; str:\n    ...\n</code></pre> <p>Format the element in an HTML string. </p> Parameter Type Default Documentation <code>format</code> <code>bool</code> <code>False</code> <code>True</code>: Formats the HTML in multiple lines, with the children in different lines.<code>False</code>: Formats the HTML element and its children in one line <code>indent</code> <code>int</code> 0 How many spaces to add for each line as a baseline <code>indent_step</code> <code>int</code> 2 How much spaces each indentation step should add"},{"location":"basic_reference/#method-__str__","title":"Method <code>__str__</code>","text":"<p>Returns the <code>to_html</code> method with the default values.</p>"},{"location":"basic_reference/#class-method-get_config_value","title":"Class method <code>get_config_value</code>","text":"<pre><code>@classmethod\ndef get_config_value(cls, value: Literal[\"tag_omission\", \"tag\"]) -&gt; Any:\n    ...\n</code></pre> <p>Returns the class configuration value for the provided type.</p> Parameter Type Default Documentation <code>value</code> <code>Literal[\"tag_omission\", \"tag\"]</code> \\ Which configuration to return"},{"location":"basic_reference/#function-htmlattribute","title":"Function <code>HtmlAttribute</code>","text":"<p>Wrapper class around <code>HtmlAttributeInfo</code>. Used for static typers to create correct class signatures.</p> <p>See <code>HtmlAttributeInfo</code> class for more information.</p>"},{"location":"basic_reference/#class-htmlattributeinfo","title":"Class <code>HtmlAttributeInfo</code>","text":"<pre><code>HtmlAttributeInfo(\n    *,\n    html_attribute: Union[str, None] = None,\n    transformer: Union[Callable[[Any], str], None] = None,\n    multi_attribute: bool = False,\n    attribute_type: HtmlAttributeType = \"attribute\",\n    init: bool = True,\n    default: Any = Undefined,\n    default_factory: Union[Callable[[], Any], None] = None,\n    kw_only: bool = True,\n)\n</code></pre> <p>Class to define which values are present on the HTML element and how to format them in the <code>to_html</code> method.</p> Parameter Type Default Documentation html_attribute <code>str</code> <code>None</code> The name of the HTML attribute to provide. When not provided, it will be defaulted to the attribute on the class. Useful for when the real attribute is a Python keyword such as <code>for</code>. For example <code>for_ = HtmlAttributeInfo(html_attribute=\"for\")</code> transformer <code>Callable[[Any], str]</code> <code>None</code> A function called in the <code>to_html</code> method. It operates on the input value to return a string to include in the HTML string. For example <code>classes: list[str] = HtmlAttributeInfo(transformer=lambda items: \", \".join(items))</code> multi_attribute <code>bool</code> <code>False</code> A flag to indicate that there are multiple individual HTML attributes linked to this value. If this flag is true, it must be linked to a <code>dict</code> structure.For example <code>aria: dict[str, str] = HtmlAttributeInfo(multi_attribute=True)</code><code>Element(aria={\"label\": \"test\", \"type\": \"button\"})</code> would be rendered as <code>&lt;element aria-label=\"test\" aria-type=\"button\" /&gt;</code> attribute_type <code>Literal[\"attribute\", \"content\"]</code> <code>\"attribute\"</code> What type of HTML content this is. This is to distinguish which class attributes need to be rendered as children and which ones are attributes. Normally, there is only one children attribute, but in theory there could be multiple. Both lists and non-lists are supported. default <code>Any</code> <code>Undefined</code> The default for this field. Only one of <code>default</code> or <code>default_factory</code> can be defined at the same time. default_factory <code>Callable[[], Any]</code> <code>None</code> <code>None</code> init <code>bool</code> <code>True</code> Whether to add this field in the <code>__init__</code> method for static typecheckers. This will actually not be enforced in the runtime logic, only in the static typing. See the dataclass_transform documentation for more information. kw_only <code>bool</code> <code>True</code> Whether this field can only be provided as a keyword and not positionally in the class initialisation. This will actually not be enforced in the runtime logic, only in the static typing. See the dataclass_transform documentation for more information."},{"location":"extended_reference/","title":"Extended Reference","text":"<p>This page provides the global attributes, the event attributes and all the HTML elements.</p>"},{"location":"extensions/","title":"Extensions","text":""},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#installations","title":"Installations","text":"<p>Installation is as simple as:</p> <pre><code>pip install html-elements\n</code></pre> <p>And afterwards in your python code</p> <pre><code>from html_elements import elements as e\n\nelement = e.P([\"Hello world\"], style={\"font-weight\": \"bold\"})\n\nassert element.to_html(format=False) == (\n    '&lt;p style=\"font-weight: bold\"&gt;Hello world&lt;/p&gt;'\n)\n</code></pre>"}]}